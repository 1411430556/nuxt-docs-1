---
title: 升级指南
description: '了解如何升级到最新的 Nuxt 版本。'
navigation.icon: i-ph-arrow-circle-up-duotone
---


## 升级 Nuxt

### 最新版本

要升级 Nuxt 到[最新版本](https://github.com/nuxt/nuxt/releases)，使用 `nuxi upgrade` 命令。

::code-group

```bash [npm]
npx nuxi upgrade
```

```bash [yarn]
yarn dlx nuxi upgrade
```

```bash [pnpm]
pnpm dlx nuxi upgrade
```

```bash [bun]
bun x nuxi upgrade
```

::

### 夜间发布通道

要在发布前使用最新的 Nuxt 构建和测试功能，阅读关于[夜间发布通道](/docs/guide/going-further/nightly-release-channel)指南。

## 测试 Nuxt 4

计划于**6月14日或之前**发布 Nuxt 4（尽管这显然取决于 Nitro 在主要发布之后是否有足够的时间在社区中进行适当的测试，因此请注意这不是一个确切的日期）。

在此之前，您可以通过 Nuxt 版本 3.12 或通过夜间发布通道来测试 Nuxt 4 的许多重大更改。

::tip{icon="i-ph-video-duotone" to="https://www.youtube.com/watch?v=r4wFKlcJK6c" target="_blank"}
观看 Alexander Lichter 的视频，了解如何立即接受 Nuxt 4 的重大更改。
::

### 选择加入 Nuxt 4

首先，接受夜间发布通道，[按照以下步骤](/docs/guide/going-further/nightly-release-channel#opting-in)。

然后，您可以将 `compatibilityVersion` 设置为匹配 Nuxt 4 的行为：

```ts twoslash [nuxt.config.ts]
export default defineNuxtConfig({
  future: {
    compatibilityVersion: 4,
  },
  // 要重新启用 _所有_ Nuxt v3 的行为，请设置以下选项：
  // srcDir: '.',
  // dir: {
  //   app: 'app'
  // },
  // experimental: {
  //   sharedPrerenderData: false,
  //   compileTemplate: true,
  //   resetAsyncDataToUndefined: true,
  //   templateUtils: true,
  //   relativeWatchPaths: true,
  //   defaults: {
  //     useAsyncData: {
  //       deep: true
  //     }
  //   }
  // },
  // unhead: {
  //   renderSSRHeadOptions: {
  //     omitLineBreaks: false
  //   }
  // }
})
```

当您将 `compatibilityVersion` 设置为 `4` 时，Nuxt 配置中的默认值将更改，以接受 Nuxt v4 的行为，但是您在测试时可以逐个重新启用 Nuxt v3 的行为，按照上面注释的行。如果有问题，请提交问题报告，以便我们在 Nuxt 或生态系统中解决它们。

### 迁移到 Nuxt 4

说明了重大更改或显著更改以及向前/向后兼容性的迁移步骤。

::alert
此部分在最终发布之前可能会发生变化，因此如果您正在使用 `compatibilityVersion: 4` 测试 Nuxt 4，请定期查看此处。
::

#### 使用 Codemods 进行迁移

为了简化升级过程，我们已与 [Codemod](https://github.com/codemod-com/codemod) 团队合作，利用一些开源 codemods 自动化许多迁移步骤。

::note
如果您遇到任何问题，请使用 `npx codemod feedback` 报告给 Codemod 团队 🙏
::

要获取 Nuxt 4 codemods 的完整列表、每个 codemod 的详细信息、它们的源代码以及运行它们的各种方式，请访问 [Codemod Registry](https://go.codemod.com/codemod-registry)。

您可以使用以下 `codemod` 配方运行本指南中提到的所有 codemods：

```bash
npx codemod@latest nuxt/4/migration-recipe
```

此命令将按顺序执行所有 codemods，并提供取消选择任何不希望运行的选项。每个 codemod 也在下面列出，以及其相应的更改，并可以独立执行。

#### 新目录结构

🚦 **影响程度**：重大

现在，Nuxt 默认采用新的目录结构，并具备向后兼容性（因此，如果 Nuxt 检测到您正在使用旧的结构，例如顶级的 `pages/` 目录，则不会应用这个新结构）。

👉 [查看完整的 RFC](https://github.com/nuxt/nuxt/issues/26444)

##### 变更内容

* 新的 Nuxt 默认 `srcDir` 默认为 `app/`，并且大多数内容都是从那里解析的。
* `serverDir` 现在默认为 `<rootDir>/server`，而不是 `<srcDir>/server`
* 默认情况下，`layers/`、`modules/` 和 `public/` 相对于 `<rootDir>` 解析
* 如果使用 [Nuxt Content v2.13+](https://github.com/nuxt/content/pull/2649)，`content/` 会相对于 `<rootDir>` 解析
* 添加了一个名为 `dir.app` 的新目录，我们在其中查找 `router.options.ts` 和 `spa-loading-template.html` - 这默认为 `<srcDir>/`

<details>

<summary>一个 v4 文件夹结构示例。</summary>

```sh
.output/
.nuxt/
app/
  assets/
  components/
  composables/
  layouts/
  middleware/
  pages/
  plugins/
  utils/
  app.config.ts
  app.vue
  router.options.ts
content/
layers/
modules/
node_modules/
public/
server/
  api/
  middleware/
  plugins/
  routes/
  utils/
nuxt.config.ts
```

</details>

👉有关更多详细信息，请查看[实施此更改的 PR](https://github.com/nuxt/nuxt/pull/27029)。

##### 变更原因

1. **性能** - 将所有代码放在仓库的根目录可能导致 `.git/` 和 `node_modules/` 文件夹被 FS 监视器扫描/包含，这可能会导致非 Mac OS 系统启动时出现显著延迟。
2. **IDE 类型安全** - `server/` 和您应用的其他部分运行在两个完全不同的上下文中，具有不同的全局导入可用性，并确保 `server/` 不在与您应用的其他部分相同的文件夹内是确保您的 IDE 能良好自动完成的重要第一步。

##### 迁移步骤

1. 创建一个名为 `app/` 的新目录。
2. 将您的 `assets/`、`components/`、`composables/`、`layouts/`、`middleware/`、`pages/`、`plugins/` 和 `utils/` 文件夹移到其中，以及 `app.vue`、`error.vue`、`app.config.ts`。如果您有 `app/router-options.ts` 或 `app/spa-loading-template.html`，这些路径保持不变。
3. 确保您的 `nuxt.config.ts`、`content/`、`layers/`、`modules/`、`public/` 和 `server/` 文件夹保留在 `app/` 文件夹之外，即在项目的根目录下。

::tip
您可以通过运行 `npx codemod@latest nuxt/4/file-structure` 来自动化此迁移。
::

但是，迁移不是 _必须_ 的。如果您希望保留当前的文件夹结构，Nuxt 应该会自动检测到（如果没有，请提出问题）。唯一的例外是，如果您 _已经_ 有一个自定义的 `srcDir`。在这种情况下，您应该意识到，您的 `modules/`、`public/` 和 `server/` 文件夹将从您的 `rootDir` 而不是从您的自定义 `srcDir` 解析。如果需要，您可以通过配置 `dir.modules`、`dir.public` 和 `serverDir` 来覆盖这一点。

您还可以使用以下配置强制使用 v3 文件夹结构：

```ts [nuxt.config.ts]
export default defineNuxtConfig({
  // 这将将新的 srcDir 默认值从 `app` 恢复为您的根目录
  srcDir: '.',
  // 这将为 `app/router.options.ts` 和 `app/spa-loading-template.html` 指定目录前缀
  dir: {
    app: 'app'
  }
})
```

#### 共享预渲染数据

🚦 **影响程度**：中等

##### 变更内容

我们启用了一项先前实验性的功能，可以在不同页面之间共享 `useAsyncData` 和 `useFetch` 调用的数据。详见 [原始 PR](https://github.com/nuxt/nuxt/pull/24894)。

##### 变更原因

此功能自动在预渲染的页面之间共享有效载荷数据。当预渲染使用 `useAsyncData` 或 `useFetch` 并在不同页面中获取相同的数据时，这可以显著改善性能。

例如，如果您的站点对于每个页面都需要一个 `useFetch` 调用（例如，为菜单获取导航数据或为 CMS 获取站点设置），那么只有当第一个使用该数据的页面预渲染时，此数据将被获取一次，然后在预渲染其他页面时缓存以供使用。

##### 迁移步骤

确保您数据的任何唯一键始终可以解析为相同的数据。例如，如果您正在使用 `useAsyncData` 获取与特定页面相关的数据，则应该提供一个唯一匹配该数据的键（`useFetch` 应该自动为您完成此操作）。

```ts [app/pages/test/[slug\\].vue]
// 这在动态页面（例如 `[slug].vue`）中是不安全的，因为路由切片对获取的数据有影响
// 但是 Nuxt 不知道这一点，因为它没有反映在键中。
const route = useRoute()
const { data } = await useAsyncData(async () => {
  return await $fetch(`/api/my-page/${route.params.slug}`)
})
// 相反，您应该使用一个唯一标识所获取数据的键。
const { data } = await useAsyncData(route.params.slug, async () => {
  return await $fetch(`/api/my-page/${route.params.slug}`)
})
```

或者，您可以使用以下配置禁用此功能：

```ts twoslash [nuxt.config.ts]
export default defineNuxtConfig({
  experimental: {
    sharedPrerenderData: false
  }
})
```

#### `useAsyncData` 和 `useFetch` 中 `data` 和 `error` 的默认值

🚦 **影响程度**：最小

##### 变更内容

现在，`useAsyncData` 返回的 `data` 和 `error` 对象将默认为 `undefined`。

##### 变更原因

先前，`data` 的初始值为 `null`，但在 `clearNuxtData` 中重置为 `undefined`。`error` 的初始值为 `null`。此变更是为了提供更大的一致性。

##### 迁移步骤

如果您正在检查 `data.value` 或 `error.value` 是否为 `null`，您可以更新这些检查以检查 `undefined`。

::tip
您可以通过运行 `npx codemod@latest nuxt/4/default-data-error-value` 来自动化此步骤。
::

如果遇到任何问题，您可以恢复回先前的行为：

```ts twoslash [nuxt.config.ts]
// @errors: 2353
export default defineNuxtConfig({
  experimental: {
    defaults: {
      useAsyncData: {
        value: 'null',
        errorValue: 'null'
      }
    }
  }
})
```

如果您在做此操作，请报告一个问题，因为我们不计划将此作为可配置项。

#### 移除在 `useAsyncData` 和 `useFetch` 中调用 `refresh` 时 `dedupe` 选项的弃用的 `boolean` 值

🚦 **影响程度**：最小

##### 变更内容

以前可以将 `dedupe: boolean` 传递到 `refresh`。这些别名是 `cancel`（`true`）和 `defer`（`false`）。

```ts twoslash [app.vue]
// @errors: 2322
const { refresh } = await useAsyncData(async () => ({ message: 'Hello, Nuxt 3!' }))

async function refreshData () {
  await refresh({ dedupe: true })
}
```

##### 更改的原因

为了更加清晰，将这些别名移除了。

当我们将 `dedupe` 作为 `useAsyncData` 的选项之一时，问题就出现了，我们移除了布尔值，因为它们是相反的。

`refresh({ dedupe: false })` 的意思是“不要取消现有请求，而是使用这个新请求”。但是在 `useAsyncData` 的选项中传递 `dedupe: true` 的意思是“如果存在待处理的请求，则不要发送任何新请求”。（请参见 [PR](https://github.com/nuxt/nuxt/pull/24564#pullrequestreview-1764584361)。）

##### 迁移步骤

迁移应该很简单：

```diff
  const { refresh } = await useAsyncData(async () => ({ message: 'Hello, Nuxt 3!' }))
  
  async function refreshData () {
-   await refresh({ dedupe: true })
+   await refresh({ dedupe: 'cancel' })

-   await refresh({ dedupe: false })
+   await refresh({ dedupe: 'defer' })
  }
```

::tip
您可以通过运行 `npx codemod@latest nuxt/4/deprecated-dedupe-value` 来自动化此步骤。
::

#### 清除 `useAsyncData` 和 `useFetch` 中 `data` 时要尊重默认值

🚦 **影响级别**：最小

##### 更改内容

如果为 `useAsyncData` 提供了自定义的 `default` 值，在调用 `clear` 或 `clearNuxtData` 时，将使用该值重置 `data`，而不仅仅是取消。

##### 更改的原因

通常，用户设置的适当的空值（例如空数组）可以避免在迭代时检查 `null`/`undefined`。当重置/清除数据时，应该尊重这些设置。

##### 迁移步骤

如果遇到任何问题，您可以暂时将行为恢复到先前版本，方法如下：

```ts twoslash [nuxt.config.ts]
// @errors: 2353
export default defineNuxtConfig({
  experimental: {
    resetAsyncDataToUndefined: true,
  }
})
```

如果这样做，请报告一个问题，因为我们不计划保持这个可配置的状态。

#### `useAsyncData` 和 `useFetch` 中的浅数据响应性

🚦 **影响级别**：最小

从 `useAsyncData`、`useFetch`、`useLazyAsyncData` 和 `useLazyFetch` 返回的 `data` 对象现在是 `shallowRef` 而不是 `ref`。

##### 更改内容

当获取新数据时，依赖于 `data` 的所有内容仍然会保持响应性，因为整个对象被替换。但是，如果您的代码更改了该数据结构中的属性，则不会触发应用程序中的任何响应性。

##### 更改的原因

对于深层嵌套的对象和数组，这带来了**显著的**性能提升，因为 Vue 不需要监视每个属性/数组的修改。在大多数情况下，`data` 也应是不可变的。

##### 迁移步骤

在大多数情况下，无需进行迁移步骤，但如果您依赖于数据对象的响应性，则有两个选择：

1. 您可以在每个可组合的基础上选择深层响应性：
   ```diff
   - const { data } = useFetch('/api/test')
   + const { data } = useFetch('/api/test', { deep: true })
   ```
1. 您可以在项目范围内更改默认行为（不推荐）：
   ```ts twoslash [nuxt.config.ts]
   export default defineNuxtConfig({
     experimental: {
       defaults: {
         useAsyncData: {
           deep: true
         }
       }
     }
   })
   ```

::tip
如果需要的话，您可以通过运行 `npx codemod@latest nuxt/4/shallow-function-reactivity` 来自动化这一步骤。
::

#### `builder:watch` 中的绝对监听路径

🚦 **影响级别**：最小

##### 更改内容

Nuxt `builder:watch` 钩子现在发出的路径是绝对路径，而不是相对于项目 `srcDir` 的路径。

##### 更改的原因

这样可以支持监听在 `srcDir` 之外的路径，并提供更好地支持层次和其他更复杂的模式。

##### 迁移步骤

我们已经主动迁移了使用此钩子的公共 Nuxt 模块。请参见 [issue #25339](https://github.com/nuxt/nuxt/issues/25339)。

但是，如果您是一个使用 `builder:watch` 钩子的模块作者，并希望保持向前/向后兼容性，可以使用以下代码确保您的代码在 Nuxt v3 和 Nuxt v4 中的行为相同：

 ```diff
+ import { relative, resolve } from 'node:fs'
  // ...
  nuxt.hook('builder:watch', async (event, path) => {
+   path = relative(nuxt.options.srcDir, resolve(nuxt.options.srcDir, path))
    // ...
  })
```

::tip
You can automate this step by running `npx codemod@latest nuxt/4/absolute-watch-path`
::

#### Removal of `window.__NUXT__` object

##### What Changed

We are removing the global `window.__NUXT__` object after the app finishes hydration.

##### Reasons for Change

This opens the way to multi-app patterns ([#21635](https://github.com/nuxt/nuxt/issues/21635)) and enables us to focus on a single way to access Nuxt app data - `useNuxtApp()`.

##### Migration Steps

The data is still available, but can be accessed with `useNuxtApp().payload`:

```diff
- console.log(window.__NUXT__)
+ console.log(useNuxtApp().payload)
```

#### 目录索引扫描

🚦 **影响级别**：中等

##### 更改内容

`middleware/` 文件夹中的子文件夹也会被扫描，并将这些文件注册为中间件。

##### 更改的原因

Nuxt 自动扫描多个文件夹，包括 `middleware/` 和 `plugins/`。

在 `plugins/` 文件夹中的子文件夹会被扫描，寻找 `index` 文件，并希望在扫描的目录之间保持这种行为一致。

##### 迁移步骤

可能不需要进行迁移，但是，如果希望恢复到以前的行为，可以添加一个过滤中间件的钩子：

```ts
export default defineNuxtConfig({
  hooks: {
    'app:resolve'(app) {
      app.middleware = app.middleware.filter(mw => !/\/index\.[^/]+$/.test(mw.path))
    }
  }
})
```

#### 模板编译更改

🚦 **影响级别**：最小

##### 更改内容

以前，Nuxt 使用 `lodash/template` 来使用 `.ejs` 文件格式/语法编译文件系统上的模板。

此外，我们还提供了一些模板实用程序（`serialize`、`importName`、`importSources`），可用于这些模板内部的代码生成，现在正在删除这些实用程序。

##### 更改的原因

在 Nuxt v3 中，我们使用了一个更加灵活和高性能的“虚拟”语法，其中包含了一个 `getContents()` 函数。

此外，`lodash/template` 有一系列的安全问题。这些问题实际上不适用于 Nuxt 项目，因为它是在构建时使用的，而不是运行时，并且是由可信任的代码使用的。然而，它们仍然会出现在安全审计中。此外，`lodash` 是一个笨重的依赖，并且大多数项目都不使用它。

最后，在 Nuxt 中直接提供代码序列化函数不理想。相反，我们维护像 [unjs/knitwork](http://github.com/unjs/knitwork) 这样的项目，可以成为您的项目的依赖项，其中可以直接报告/解决安全问题，而无需升级 Nuxt 本身。

##### 迁移步骤

我们已经提出了更新使用 EJS 语法的模块的 PR，但是如果您需要自己处理此问题，有三种向后/向前兼容的替代方法：

* 将字符串插值逻辑直接移动到 `getContents()` 中。
* 使用自定义函数处理替换，例如在 https://github.com/nuxt-modules/color-mode/pull/240 中所示。
* 继续使用 `lodash`，作为 _您_ 项目的依赖项而不是 Nuxt 的依赖项：

```diff
+ import { readFileSync } from 'node:fs'
+ import { template } from 'lodash-es'
  // ...
  addTemplate({
    fileName: 'appinsights-vue.js'
    options: { /* some options */ },
-   src: resolver.resolve('./runtime/plugin.ejs'),
+   getContents({ options }) {
+     const contents = readFileSync(resolver.resolve('./runtime/plugin.ejs'), 'utf-8')
+     return template(contents)({ options })
+   },
  })
```

最后，如果您正在使用模板实用程序 (`serialize`、`importName`、`importSources`)，您可以使用 `knitwork` 中的实用程序替换它们：

```ts
import { genDynamicImport, genImport, genSafeVariableName } from 'knitwork'

const serialize = (data: any) => JSON.stringify(data, null, 2).replace(/"{(.+)}"(?=,?$)/gm, r => JSON.parse(r).replace(/^{(.*)}$/, '$1'))

const importSources = (sources: string | string[], { lazy = false } = {}) => {
  return toArray(sources).map((src) => {
    if (lazy) {
      return `const ${genSafeVariableName(src)} = ${genDynamicImport(src, { comment: `webpackChunkName: ${JSON.stringify(src)}` })}`
    }
    return genImport(src, genSafeVariableName(src))
  }).join('\n')
}

const importName = genSafeVariableName
```

::tip
您可以通过运行 `npx codemod@latest nuxt/4/template-compilation-changes` 来自动化此步骤。
::

#### 实验性功能的删除

🚦 **影响级别**：最小

##### 更改内容

Nuxt 4 中不再可配置四个实验性功能：

* `experimental.treeshakeClientOnly` 将为 `true`（自 v3.0 起默认）
* `experimental.configSchema` 将为 `true`（自 v3.3 起默认）
* `experimental.polyfillVueUseHead` 将为 `false`（自 v3.4 起默认）
* `experimental.respectNoSSRHeader` 将为 `false`（自 v3.4 起默认）
* `vite.devBundler` 不再可配置 - 默认将使用 `vite-node`

##### 更改的原因

这些选项已经设置为它们当前的值已经一段时间了，我们没有理由认为它们需要保持可配置。

##### 迁移步骤

* `polyfillVueUseHead` 可以在用户环境中通过[此插件](https://github.com/nuxt/nuxt/blob/f209158352b09d1986aa320e29ff36353b91c358/packages/nuxt/src/head/runtime/plugins/vueuse-head-polyfill.ts#L10-L11)进行实现。

* `respectNoSSRHeader` 可以在用户环境中通过[服务器中间件](https://github.com/nuxt/nuxt/blob/c660b39447f0d5b8790c0826092638d321cd6821/packages/nuxt/src/core/runtime/nitro/no-ssr.ts#L8-L9)进行实现。

## Nuxt 2 vs Nuxt 3+

在下表中，简要比较了 Nuxt 的 3 个版本：

特性 / 版本        | Nuxt 2          | Nuxt Bridge      | Nuxt 3+
-------------------|-----------------|------------------|---------
Vue                | 2               | 2                | 3
稳定性              | 😊 稳定         | 😊 稳定         | 😊 稳定
性能                | 🏎 快          | ✈️ 更快         | 🚀 最快
Nitro 引擎          | ❌             | ✅               | ✅
ESM 支持            | 🌙 部分        | 👍 更好        | ✅
TypeScript         | ☑️ 可选        | 🚧 部分       | ✅
Composition API    | ❌             | 🚧 部分       | ✅
Options API        | ✅             | ✅               | ✅
组件自动导入         | ✅             | ✅               | ✅
`<script setup>` 语法 | ❌             | 🚧 部分      | ✅
自动导入            | ❌             | ✅               | ✅
webpack            | 4              | 4                | 5
Vite               | ⚠️ 部分       | 🚧 部分       | ✅
Nuxi CLI           | ❌ 旧版          | ✅ nuxi          | ✅ nuxi
静态站点            | ✅             | ✅               | ✅

## 从 Nuxt 2 迁移到 Nuxt 3+

The migration guide provides a step-by-step comparison of Nuxt 2 features to Nuxt 3 features and guidance to adapt your current application.

::read-more{to="/docs/migration/overview"}
查看 **从 Nuxt 2 迁移到 Nuxt 3** 的迁移指南。
::

## 从 Nuxt 2 迁移到 Nuxt Bridge

如果您希望逐步将您的 Nuxt 2 应用程序迁移到 Nuxt 3，您可以使用 Nuxt Bridge。Nuxt Bridge 是一个兼容层，它允许您在 Nuxt 2 中使用 Nuxt 3+ 功能，并具有选择加入机制。

::read-more{to="/docs/bridge/overview"}
**从 Nuxt 2 迁移到 Nuxt Bridge**
::
