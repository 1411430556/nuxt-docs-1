---
title: 升级指南
description: '了解如何升级到最新的 Nuxt 版本。'
navigation.icon: i-ph-arrow-circle-up
---

## 升级 Nuxt

### 最新发布版本

要将 Nuxt 升级到 [最新发布版本](https://github.com/nuxt/nuxt/releases)，请使用 `nuxi upgrade` 命令。

::package-managers

```bash [npm]
npx nuxi upgrade
```

```bash [yarn]
yarn dlx nuxi upgrade
```

```bash [pnpm]
pnpm dlx nuxi upgrade
```

```bash [bun]
bun x nuxi upgrade
```

::

### 每日构建发布渠道

要使用最新的 Nuxt 构建并测试发布前的功能，请阅读 [每日构建发布渠道](/docs/guide/going-further/nightly-release-channel) 指南。

::alert{type="warning"}
每日构建发布渠道的 `latest` 标签目前跟踪的是 Nuxt v4 分支，这意味着此时很可能会有不兼容的更改 - 小心！

您可以选择加入 3.x 分支的每日构建发布，通过 `"nuxt": "npm:nuxt-nightly@3x"`。
::

## 测试 Nuxt 4

Nuxt 4 的发布日期将**另行通知**。这取决于在 Nitro 重大发布之后是否有足够的时间进行社区测试。您可以在 [这个 PR](https://github.com/unjs/nitro/pull/2521) 中关注 Nitro 发布的进展。

在发布之前，可以测试许多 Nuxt 4 相较于 Nuxt 版本 3.12+ 的断裂性更改。

::tip{icon="i-ph-video" to="https://www.youtube.com/watch?v=r4wFKlcJK6c" target="_blank"}
观看 Alexander Lichter 的视频，了解如何选择加入 Nuxt 4 的断裂性更改。
::

### 选择加入 Nuxt 4

首先，将 Nuxt 升级到 [最新发布版本](https://github.com/nuxt/nuxt/releases)。

然后您可以设置 `compatibilityVersion` 以匹配 Nuxt 4 的行为：

```ts twoslash [nuxt.config.ts]
export default defineNuxtConfig({
  future: {
    compatibilityVersion: 4,
  },
  // 要重新启用 Nuxt v3 的 **所有** 行为，请设置以下选项：
  // srcDir: '.',
  // dir: {
  //   app: 'app'
  // },
  // experimental: {
  //   sharedPrerenderData: false,
  //   compileTemplate: true,
  //   resetAsyncDataToUndefined: true,
  //   templateUtils: true,
  //   relativeWatchPaths: true,
  //   normalizeComponentNames: false
  //   defaults: {
  //     useAsyncData: {
  //       deep: true
  //     }
  //   }
  // },
  // unhead: {
  //   renderSSRHeadOptions: {
  //     omitLineBreaks: false
  //   }
  // }
})
```

当您将 `compatibilityVersion` 设置为 `4` 时，整个 Nuxt 配置中的默认设置将更改以选择加入 Nuxt v4 的行为，但在测试时，您可以按行重新启用 Nuxt v3 的行为，遵循上面的注释行。如果存在问题，请提交问题，以便我们可以在 Nuxt 或生态系统中解决它们。

### 迁移到 Nuxt 4

这里将指出断裂性或重大更改，并提供向后/向前兼容的迁移步骤。

::alert
此部分在最终发布之前可能会发生变化，因此如果您正在使用 `compatibilityVersion: 4` 测试 Nuxt 4，请定期查看此处。
::

#### 使用 Codemods 进行迁移

为了简化升级过程，我们与 [Codemod](https://github.com/codemod-com/codemod) 团队合作，使用一些开源的 codemods 自动化许多迁移步骤。

::note
如果您遇到任何问题，请通过 `npx codemod feedback` 向 Codemod 团队报告 🙏
::

要获取完整的 Nuxt 4 codemods 列表、每个项目的详细信息、其来源以及不同的运行方式，请访问 [Codemod 注册表](https://go.codemod.com/codemod-registry)。

您可以使用以下 `codemod` 食谱运行本指南中提到的所有 codemods：

```bash
npx codemod@latest nuxt/4/migration-recipe
```

此命令将按顺序执行所有 codemods，并可以选择不运行您不想执行的任何文件。每个 codemod 也在下方与其各自的更改一起列出，可以独立执行。

#### 新目录结构

🚦 **影响级别**：重大

Nuxt 现在默认使用新目录结构，并保持向后兼容性（如果 Nuxt 检测到您使用旧结构，如顶层 `pages/` 目录，则新结构将不适用）。

👉 [查看完整的 RFC](https://github.com/nuxt/nuxt/issues/26444)

##### 变化内容

* 新的 Nuxt 默认 `srcDir` 是 `app/`，大多数内容从此处解析。
* `serverDir` 的默认值现在是 `<rootDir>/server` 而不是 `<srcDir>/server`
* `layers/`、`modules/` 和 `public/` 默认相对 `<rootDir>` 解析
* 如果使用 [Nuxt Content v2.13+](https://github.com/nuxt/content/pull/2649)，`content/` 相对于 `<rootDir>` 解析
* 添加了一个新的 `dir.app`，这是我们查找 `router.options.ts` 和 `spa-loading-template.html` 的目录 - 默认值是 `<srcDir>/`

<details>

<summary>一个 v4 目录结构示例。</summary>

```sh
.output/
.nuxt/
app/
  assets/
  components/
  composables/
  layouts/
  middleware/
  pages/
  plugins/
  utils/
  app.config.ts
  app.vue
  router.options.ts
content/
layers/
modules/
node_modules/
public/
server/
  api/
  middleware/
  plugins/
  routes/
  utils/
nuxt.config.ts
```

</details>

👉 欲了解更多详细信息，请参阅 [实施此更改的 PR](https://github.com/nuxt/nuxt/pull/27029)。

##### 更改原因

1. **性能** - 将所有代码放在代码库的根目录会导致 `.git/` 和 `node_modules/` 文件夹被 FS 观察者扫描/包含，从而显著延迟非 Mac OS 的启动。
2. **IDE 类型安全** - `server/` 和您应用的其他部分在两个完全不同的上下文中运行，具有不同的全局导入可用，确保 `server/` 不在与您应用的其他部分相同的文件夹中是确保您在 IDE 中获得良好自动完成功能的重要一步。

##### 迁移步骤

1. 创建一个名为 `app/` 的新目录。
2. 将您的 `assets/`、`components/`、`composables/`、`layouts/`、`middleware/`、`pages/`、`plugins/` 和 `utils/` 文件夹移到该目录下，以及 `app.vue`、`error.vue`、`app.config.ts`。如果您有 `app/router-options.ts` 或 `app/spa-loading-template.html`，这些路径保持不变。
3. 确保您的 `nuxt.config.ts`、`content/`、`layers/`、`modules/`、`public/` 和 `server/` 文件夹保持在 `app/` 文件夹外，位于项目根目录。
4. 记得更新任何第三方配置文件以适应新目录结构，例如您的 `tailwindcss` 或 `eslint` 配置（如有必要 - `@nuxtjs/tailwindcss` 应该会自动正确配置 `tailwindcss`）。

::tip
您可以通过运行 `npx codemod@latest nuxt/4/file-structure` 自动执行此迁移
::

但是，迁移并不是强制的。如果您希望保持当前的文件夹结构，Nuxt 应该会自动检测到（如果未检测到，请提出问题）。唯一的例外是，如果您已经有一个自定义的 `srcDir`。在这种情况下，您应该意识到您的 `modules/`、`public/` 和 `server/` 文件夹将相对于您的 `rootDir` 而不是您的自定义 `srcDir` 解析。如有需要，您可以通过配置 `dir.modules`、`dir.public` 和 `serverDir` 覆盖此设置。

您还可以使用以下配置强制 v3 文件夹结构：

```ts [nuxt.config.ts]
export default defineNuxtConfig({
  // 这将新的 srcDir 默认从 `app` 恢复到您的根目录
  srcDir: '.',
  // 这指定 `app/router.options.ts` 和 `app/spa-loading-template.html` 的目录前缀
  dir: {
    app: 'app'
  }
})
```

#### 组件名称规范化

🚦 **影响级别**：中等

Vue 现在将生成与 Nuxt 组件命名模式匹配的组件名称。

##### 变化内容

默认情况下，如果您没有手动设置，Vue 
将为组件分配一个与组件文件名匹配的组件名称。

```bash [目录结构]
├─ components/
├─── SomeFolder/
├───── MyComponent.vue
```

在这种情况下，在 Vue 看来，组件名称将是 `MyComponent`。如果您想与其一起使用 `<KeepAlive>`，或在 Vue DevTools 中识别它，您需要使用此名称。

但要自动导入它，您需要使用 `SomeFolderMyComponent`。

通过此更改，这两个值将匹配，Vue 将生成与 Nuxt 组件命名模式匹配的组件名称。

##### 迁移步骤

确保在使用 `@vue/test-utils` 中的 `findComponent` 的任何测试中使用更新的名称，并在任何依赖于组件名称的 `<KeepAlive>` 中使用。

另外，目前您可以通过以下方式禁用此行为：

```ts twoslash [nuxt.config.ts]
export default defineNuxtConfig({
  experimental: {
    normalizeComponentNames: false
  }
})
```

#### 共享预渲染数据

🚦 **影响级别**：中等

##### 变化内容

我们启用了一个以前实验性的功能，可以在不同页面之间共享来自 `useAsyncData` 和 `useFetch` 调用的数据。请参见 [原始 PR](https://github.com/nuxt/nuxt/pull/24894)。

##### 更改原因

此功能在预渲染的页面之间自动共享有效负载 _数据_。这可以显著提高预渲染使用 `useAsyncData` 或 `useFetch` 并在不同页面中获取相同数据的站点的性能。

例如，如果您的站点每个页面都需要 `useFetch` 调用（例如，从 CMS 获取菜单的导航数据或站点设置），则在预渲染使用它的第一页时，只需获取一次数据，然后在预渲染其他页面时缓存供使用。

##### 迁移步骤

确保您数据的唯一键始终可以解析为相同的数据。例如，如果您使用 `useAsyncData` 获取与特定页面相关的数据，您应提供一个唯一匹配该数据的键（`useFetch` 应该会为您自动执行此操作）。

```ts [app/pages/test/[slug\\].vue]
// 这在动态页面（例如 `[slug].vue`）中将是不安全的，因为路由 slug 会影响获取的数据，
// 但 Nuxt 无法知道，因为它未反映在键中。
const route = useRoute()
const { data } = await useAsyncData(async () => {
  return await $fetch(`/api/my-page/${route.params.slug}`)
})
// 相反，您应该使用唯一标识所获取数据的键。
const { data } = await useAsyncData(route.params.slug, async () => {
  return await $fetch(`/api/my-page/${route.params.slug}`)
})
```

或者，您可以通过以下方式禁用此功能：

```ts twoslash [nuxt.config.ts]
export default defineNuxtConfig({
  experimental: {
    sharedPrerenderData: false
  }
})
```

#### `useAsyncData` 和 `useFetch` 中 `data` 和 `error` 的默认值

🚦 **影响级别**：最小

##### 变化内容

`useAsyncData` 返回的 `data` 和 `error` 对象现在默认值为 `undefined`。

##### 更改原因

之前 `data` 被初始化为 `null`，但在 `clearNuxtData` 中重置为 `undefined`。`error` 被初始化为 `null`。此更改旨在带来更大的一致性。

##### 迁移步骤

如果您在检查 `data.value` 或 `error.value` 是否为 `null`，您可以将这些检查更改为检查 `undefined`。

::tip
您可以通过运行 `npx codemod@latest nuxt/4/default-data-error-value` 自动执行此步骤
::

如果您遇到任何问题，您可以通过以下方式恢复先前的行为：

```ts twoslash [nuxt.config.ts]
// @errors: 2353
export default defineNuxtConfig({
  experimental: {
    defaults: {
      useAsyncData: {
        value: 'null',
        errorValue: 'null'
      }
    }
  }
})
```

如果您执行此操作，请报告问题，因为我们不打算将其保持为可配置状态。

#### 移除 `useAsyncData` 和 `useFetch` 中 `refresh` 时 `dedupe` 选项的弃用 `boolean` 值

🚦 **影响级别**：最小

##### 变化内容

之前可以将 `dedupe: boolean` 传递给 `refresh`。这些是 `cancel` (`true`) 和 `defer` (`false`) 的别名。

```ts twoslash [app.vue]
// @errors: 2322
const { refresh } = await useAsyncData(async () => ({ message: 'Hello, Nuxt 3!' }))

async function refreshData () {
  await refresh({ dedupe: true })
}
```

##### 更改原因

为了更清晰，移除了这些别名。

问题出现在将 `dedupe` 作为选项添加到 `useAsyncData` 时，并移除了布尔值，因为它们最终成为了 _相反_。

`refresh({ dedupe: false })` 的意思是“不要 _取消_ 现有请求以换取这个新请求”。但在 `useAsyncData` 的选项中传递 `dedupe: true` 意味着“如果有现有的待处理请求，则不要发起任何新请求”。（参见 [PR](https://github.com/nuxt/nuxt/pull/24564#pullrequestreview-1764584361)。）

##### 迁移步骤

迁移应该很简单：

```diff
  const { refresh } = await useAsyncData(async () => ({ message: 'Hello, Nuxt 3!' }))
  
  async function refreshData () {
-   await refresh({ dedupe: true })
+   await refresh({ dedupe: 'cancel' })

-   await refresh({ dedupe: false })
+   await refresh({ dedupe: 'defer' })
  }
```

::tip
您可以通过运行 `npx codemod@latest nuxt/4/deprecated-dedupe-value` 自动执行此步骤
::

#### 在 `useAsyncData` 和 `useFetch` 中清除 `data` 时遵循默认值

🚦 **影响级别**：最小

##### 变化内容

如果您为 `useAsyncData` 提供了自定义 `default` 值，那么在调用 `clear` 或 `clearNuxtData` 时将使用此值重置，而不是简单地取消设置。

##### 更改原因

用户通常设置一个适当的空值，如空数组，以避免在迭代时检查 `null`/`undefined`。在重置/清除数据时应予以尊重。

##### 迁移步骤

如果您遇到任何问题，您可以暂时通过以下方式恢复先前的行为：

```ts twoslash [nuxt.config.ts]
// @errors: 2353
export default defineNuxtConfig({
  experimental: {
    resetAsyncDataToUndefined: true,
  }
})
```

如果您这样做，请报告问题，因为我们不打算将其保持为可配置状态。

#### 在 `useAsyncData` 和 `useFetch` 中的浅层数据反应性变更

🚦 **影响级别**：最小

从 `useAsyncData`、`useFetch`、`useLazyAsyncData` 和 `useLazyFetch` 返回的 `data` 对象现在是一个 `shallowRef` 而不是 `ref`。

##### 变化内容

当获取新数据时，依赖于 `data` 的任何内容仍然会是反应式的，因为整个对象会被替换。但是如果您的代码更改了该数据结构中的某个属性，这将不会触发您应用中的任何反应性。

##### 更改原因

这为深层嵌套的对象和数组带来了 **显著** 的性能改进，因为 Vue 不需要监视每个属性/数组的修改。在大多数情况下，`data` 也应该是不可变的。

##### 迁移步骤

在大多数情况下，不需要迁移步骤，但如果您依赖于数据对象的反应性，那么您有两个选项：

1. 您可以逐个组合选择加入深层反应性：
   ```diff
   - const { data } = useFetch('/api/test')
   + const { data } = useFetch('/api/test', { deep: true })
   ```
2. 您可以在项目范围内更改默认行为（不推荐）：
   ```ts twoslash [nuxt.config.ts]
   export default defineNuxtConfig({
     experimental: {
       defaults: {
         useAsyncData: {
           deep: true
         }
       }
     }
   })
   ```

::tip
如有需要，您可以通过运行 `npx codemod@latest nuxt/4/shallow-function-reactivity` 自动执行此步骤
::

#### 在 `builder:watch` 中的绝对观察路径

🚦 **影响级别**：最小

##### 变化内容

Nuxt `builder:watch` 钩子现在发出的是相对于您的项目 `srcDir` 的绝对路径，而不是相对路径。

##### 更改原因

这让我们可以支持监视位于 `srcDir` 外部的路径，并对层和其他更复杂的模式提供更好的支持。

##### 迁移步骤

我们已主动迁移我们意识到使用此钩子的公共 Nuxt 模块。请参阅 [问题 #25339](https://github.com/nuxt/nuxt/issues/25339)。

但是，如果您是使用 `builder:watch` 钩子的模块作者，并希望保持向后/向前兼容，您可以使用以下代码以确保您的代码在 Nuxt v3 和 Nuxt v4 中的工作方式相同：

```diff
+ import { relative, resolve } from 'node:fs'
  // ...
  nuxt.hook('builder:watch', async (event, path) => {
+   path = relative(nuxt.options.srcDir, resolve(nuxt.options.srcDir, path))
    // ...
  })
```

::tip
您可以通过运行 `npx codemod@latest nuxt/4/absolute-watch-path` 自动执行此步骤
::

#### 移除 `window.__NUXT__` 对象

##### 变化内容

在应用完成水合之后，我们将移除全局的 `window.__NUXT__` 对象。

##### 更改原因

这为多应用模式开辟了道路 ([#21635](https://github.com/nuxt/nuxt/issues/21635))，并使我们能够专注于访问 Nuxt 应用数据的单一方式 - `useNuxtApp()`。

##### 迁移步骤

数据仍然可用，但可以通过 `useNuxtApp().payload` 访问：

```diff
- console.log(window.__NUXT__)
+ console.log(useNuxtApp().payload)
```

#### 目录索引扫描

🚦 **影响级别**：中等

##### 变化内容

您的 `middleware/` 文件夹中的子文件夹也会扫描 `index` 文件，并且这些现在也会注册为您项目中的中间件。

##### 更改原因

Nuxt 自动扫描多个文件夹，包括 `middleware/` 和 `plugins/`。

`plugins/` 文件夹中的子文件夹会扫描 `index` 文件，我们希望使这种行为在扫描目录之间保持一致。

##### 迁移步骤

可能不需要迁移，但如果您希望恢复之前的行为，可以添加一个钩子以过滤出这些中间件：

```ts
export default defineNuxtConfig({
  hooks: {
    'app:resolve'(app) {
      app.middleware = app.middleware.filter(mw => !/\/index\.[^/]+$/.test(mw.path))
    }
  }
})
```

#### 模板编译更改

🚦 **影响级别**：最小

##### 变化内容

之前，Nuxt 使用 `lodash/template` 编译位于文件系统上的模板，采用 `.ejs` 文件格式/语法。

此外，我们提供了一些可以在这些模板中用于代码生成的模板工具（`serialize`、`importName`、`importSources`），这些现在也被移除。

##### 更改原因

在 Nuxt v3 中，我们转向了一种“虚拟”语法，采用 `getContents()` 函数，这更加灵活和高效。

此外，`lodash/template` 有一系列的安全问题。这些问题实际上并不适用于 Nuxt 项目，因为它在构建时而非运行时使用，并且由受信代码控制。然而，它们在安全审计中仍然会出现。此外，`lodash` 是一个庞大的依赖，而大多数项目不使用它。

最后，直接在 Nuxt 中提供代码序列化函数并不理想。相反，我们维护像 [unjs/knitwork](http://github.com/unjs/knitwork) 这样的项目，这些项目可以成为您项目的依赖，其中的安全问题可以直接报告/解决，而无需升级 Nuxt 本身。

##### 迁移步骤

我们已提出 PR 来更新使用 EJS 语法的模块，但如果您需要自己执行此操作，您有三种兼容向后/向前的替代方案：

* 将您的字符串插值逻辑直接放入 `getContents()` 中。
* 使用自定义函数处理替换，例如在 https://github.com/nuxt-modules/color-mode/pull/240。
* 继续将 `lodash` 作为您的项目的依赖，而不是 Nuxt：

```diff
+ import { readFileSync } from 'node:fs'
+ import { template } from 'lodash-es'
  // ...
  addTemplate({
    fileName: 'appinsights-vue.js'
    options: { /* some options */ },
-   src: resolver.resolve('./runtime/plugin.ejs'),
+   getContents({ options }) {
+     const contents = readFileSync(resolver.resolve('./runtime/plugin.ejs'), 'utf-8')
+     return template(contents)({ options })
+   },
  })
```

最后，如果您正在使用模板工具（`serialize`、`importName`、`importSources`），则可以通过如下方式替换它们：

```ts
import { genDynamicImport, genImport, genSafeVariableName } from 'knitwork'

const serialize = (data: any) => JSON.stringify(data, null, 2).replace(/"{(.+)}"(?=,?$)/gm, r => JSON.parse(r).replace(/^{(.*)}$/, '$1'))

const importSources = (sources: string | string[], { lazy = false } = {}) => {
  return toArray(sources).map((src) => {
    if (lazy) {
      return `const ${genSafeVariableName(src)} = ${genDynamicImport(src, { comment: `webpackChunkName: ${JSON.stringify(src)}` })}`
    }
    return genImport(src, genSafeVariableName(src))
  }).join('\n')
}

const importName = genSafeVariableName
```

::tip
您可以通过运行 `npx codemod@latest nuxt/4/template-compilation-changes` 自动执行此步骤
::

#### 移除实验性功能

🚦 **影响级别**：最小

##### 变化内容

四个实验性功能不再在 Nuxt 4 中可配置：

* `experimental.treeshakeClientOnly` 将为 `true`（自 v3.0 起默认）
* `experimental.configSchema` 将为 `true`（自 v3.3 起默认）
* `experimental.polyfillVueUseHead` 将为 `false`（自 v3.4 起默认）
* `experimental.respectNoSSRHeader` 将为 `false`（自 v3.4 起默认）
* `vite.devBundler` 不再可配置 - 默认使用 `vite-node`

##### 更改原因

这些选项的当前值已经设置了一段时间，我们没有理由认为它们需要保持可配置状态。

##### 迁移步骤

* `polyfillVueUseHead` 可以在用户领域实现，使用 [此插件](https://github.com/nuxt/nuxt/blob/f209158352b09d1986aa320e29ff36353b91c358/packages/nuxt/src/head/runtime/plugins/vueuse-head-polyfill.ts#L10-L11)

* `respectNoSSRHeader` 可以在用户领域实现，使用 [服务端中间件](https://github.com/nuxt/nuxt/blob/c660b39447f0d5b8790c0826092638d321cd6821/packages/nuxt/src/core/runtime/nitro/no-ssr.ts#L8-L9)

## Nuxt 2 与 Nuxt 3+

下表是 Nuxt 3 版本的快速比较：

特性 / 版本        | Nuxt 2          | Nuxt Bridge      | Nuxt 3+
--------------------|-----------------|------------------|---------
Vue                 | 2               | 2                | 3
稳定性              | 😊 稳定        | 😊 稳定           | 😊 稳定
性能                | 🏎 快速        | ✈️ 更快           | 🚀 最快
Nitro 引擎          | ❌             | ✅                | ✅
ESM 支持            | 🌙 部分        | 👍 更好           | ✅
TypeScript          | ☑️ 自选       | 🚧 部分          | ✅
组合式 API         | ❌             | 🚧 部分          | ✅
选项 API           | ✅             | ✅                | ✅
组件自动导入       | ✅             | ✅                | ✅
`<script setup>` 语法  | ❌             | 🚧 部分          | ✅
自动导入           | ❌             | ✅                | ✅
webpack             | 4               | 4                 | 5
Vite                | ⚠️ 部分        | 🚧 部分          | ✅
Nuxi CLI            | ❌ 旧版       | ✅ nuxi           | ✅ nuxi
静态网站            | ✅             | ✅                | ✅

## 从 Nuxt 2 到 Nuxt 3+

迁移指南提供了 Nuxt 2 特性与 Nuxt 3+ 特性的逐步比较和指导，以便适应您当前的应用程序。

::read-more{to="/docs/migration/overview"}
查看 **从 Nuxt 2 到 Nuxt 3 的迁移指南**。
::

## 从 Nuxt 2 到 Nuxt Bridge

如果您希望逐步将 Nuxt 2 应用程序迁移到 Nuxt 3，可以使用 Nuxt Bridge。Nuxt Bridge 是一个兼容层，允许您在 Nuxt 2 中使用 Nuxt 3+ 特性，并提供选择加入机制。

::read-more{to="/docs/bridge/overview"}
**从 Nuxt 2 迁移到 Nuxt Bridge**
::
